# 计算机网络常见面试问题

## 应用层

应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、哪些字段等

### HTTP 协议

HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。

HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。

HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护 一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 `Connection: keep-alive` 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持 同时建立 6 个持久连接。

HTTP 报文有两种，一种是请求报文，一种是响应报文。

#### HTTP 请求报文

```http
GET / HTTP/1.1
User-Agent:  Mozilla/5.0 (Macintosh; Intel Mac OS X 11_0_0)
Accept: */*

// 实体主体
```

HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这个空行不能省略，它用来划分首部与实体。

请求行包含三个字段：方法字段、URL 字段和 HTTP 版本字段。

方法字段可以取几种不同的值，一般有 GET、POST、HEAD、PUT 和 DELETE。一般 GET 方法只被用于向服务器获取数据。 POST 方法用于将实体提交到指定的资源，通常会造成服务器资源的修改。HEAD 方法与 GET 方法类似，但是在返回的响应 中，不包含请求对象。PUT 方法用于上传文件到服务器，DELETE 方法用于删除服务器上的对象。虽然请求的方法很多，但 更多表达的是一种语义上的区别，并不是说 POST 能做的事情，GET 就不能做了，主要看我们如何选择。更多的方法可以参 看[文档](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods)。

#### HTTP 响应报文

```http
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html>
  <body>Hello World</body>
</html>
```

```http
HTTP/1.1 200 OK
Server: nginx/1.10.3 (Ubuntu)
Date: Tue, 02 Mar 2021 03:39:52 GMT
Content-Type: text/html; charset=utf-8
Transfer-Encoding: chunked
Connection: keep-alive
X-Frame-Options: SAMEORIGIN
Vary: Cookie
Set-Cookie: csrftoken=7CmrZMPY9ciVVRnl9ZS7DuFBx09wHaoLS2YEzzCV7P2fTSmk1hjN2htpf6jIY1Ra; expires=Tue, 01 Mar 2022 03:39:52 GMT; Max-Age=31449600; Path=/; SameSite=Lax
Content-Encoding: gzip
```

HTTP 响应报文的第一行是状态行，后面的行是首部行，最后是实体主体。

状态行包含了三个字段：版本协议、状态码和相应的状态信息

实体部分是报文的主要部分，包含了所请求的对象。

**常见状态分类**

1\*\* - 信息，服务器收到请求，需要请求者继续执行操作

2\*\* - 成功，操作被成功接受并处理

3\*\* - 重定向，需要进一步的操作以完成请求

4\*\* - 客户端错误，请求包含语法错误或无法完成请求

5\*\* - 服务器错误，服务器在处理请求的过程中发生错误

**常见状态**

100 - 继续，客户端继续其请求，101 - 切换协议

200 - 请求成功、202 - 已接受请求，但尚未处理完成

300 - 多种选择、301 - 永久移动，资源（网页等）被永久转移到其它 URL、302 - 临时移动、304 - 所请求资源未修改

400 - 客户端请求语法错误、401 - 请求要求用户身份认证、403 - 服务端理解客户端请求，但拒绝执行请求、404 - 请求的资源不存在

500 - 服务器内部错误、502 - 作为网关或代理的服务器尝试执行请求时，从远程服务器收到了一个无效的响应

**首部行**

首部可以分为四种首部，请求首部、响应首部、通用首部、实体首部；

通用首部和实体首部在请求报文和响应报文中都可以设置，区别在与请求首部和响应首部。

常见的请求首部：Accept（可接受媒体资源类型）、Accept-Charset、Host（请求主机名）

常见的响应首部：ETag（资源的匹配信息）、Location（客户端重定向的 URI）

常见的通用首部：Cache-Control（控制缓冲策略）、Connection（管理持久连接）

常见的实体首部：Content-Length（实体主体大小）、Expires（实体主体过期时间）、Last-Modified（资源最后修改时间）

学习资料：[《HTTP 首部字段详细介绍》](https://www.cnblogs.com/jycboy/p/http_head.html)、[《图解 HTTP》](https://blog.csdn.net/qq_34289537/article/details/52971516)

#### HTTP/1.1 协议

HTTP/1.1 默认使用了持久连接，多个请求可以复用同一个 TCP 连接，但是在同一个 TCP 连接里面，数据请求的通信次序 是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许多请求排队等待的情况，这种情况被称为“队头堵塞”。队头阻塞会导致持久连接在达到最大数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。

为了避免这个问题，一个是减少请求数，一个是同时打开多个持久连接。这就是我们对网站优化时，使用雪碧图、合并脚本的原因。

#### HTTP/2 协议

**二进制协议**

**多路复用**

**数据流**

**头信息压缩**

**服务器推送**

### HTTPS 协议

**HTTP 存在的问题**

- HTTP 报文使用明文方式发送，可能被第三方窃听
- HTTP 报文可能被第三方截取后修改通信内容，接收方无法发现报文内容修改
- HTTP 还存在认证的问题，第三方可以冒充他人参与通信

HTTPS，超文本传输安全协议，基于 HTTP 协议，使用 TLS/SSL 对数据进行加密传输。使用 TLS/SSL 协议，所有信息都是加密的，并且提供一种校验机制，信息一旦被篡改，通信双方会立刻发现。还配备了身份证书，防止身份被冒充的情况出现。

#### TLS 握手过程

1. 客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数（Client random）、以及客户端支持的加密方法；
2. 服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、生成的一个随机数（Server random）；
3. 客户端确认服务器证书有效后，生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的 hash 值，用来供服务器检验；
4. 服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验；
5. 客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。

![bg2014092003](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092003.png)

图片来源：[阮一峰的网络日志 - 图解 SSL/TLS 协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)

**实现原理**

TLS 的握手过程主要用到了三个方法来保证传输的安全。

首先是对称加密的方法，对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就 是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。

非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只 有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加 密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。

因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以 非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存 在的问题。

但是现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取 了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥 解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。

为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成 一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合 在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证 处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改 了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有 这样我们才能保证数据的安全。

详细资料可以参考： [《一个故事讲完 https》](https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA) 、[《SSL/TLS 协议运行机制的概述》](http://ruanyifeng.com/blog/2014/02/ssl_tls.html) 、[《图解 SSL/TLS 协议》](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html) 、[《RSA 算法原理（一）》](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html) 、[《RSA 算法原理（二）》](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)、 [《分分钟让你理解 HTTPS》](https://juejin.im/post/5ad6ad575188255c272273c4)

### DNS 协议

DNS 协议提供的是主机名到 IP 地址的转换服务，即常说的域名系统。它还是一个分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。DNS 协议运行在 UDP 协议之上，使用 53 端口号

**查询过程**

DNS 的查询过程一般为，我们首先将 DNS 请求发送到本地 DNS 服务器，由本地 DNS 服务器来代为请求。

1. 从"根域名服务器"查到"顶级域名服务器"的 NS 记录和 A 记录（ IP 地址）。
2. 从"顶级域名服务器"查到"次级域名服务器"的 NS 记录和 A 记录（ IP 地址）。
3. 从"次级域名服务器"查出"主机名"的 IP 地址。

## 传输层

传输层协议主要是为不同主机上的不同进程间提供了逻辑通信的功能。传输层只工作在端系统中。

#### 多路复用与多路分解

### UDP 协议

UDP 是一种无连接的，不可靠的传输层协议。它只提供了传输层需要实现的最低限度的功能，除了复用/分解功能和少量的差错检测外，它几乎没有对 IP 增加其他的东西。UDP 协议适用于对实时性要求高的应用场景。

特点：

- 使用 UDP 时，在发送报文段之前，通信双方没有握手的过程，因此 UDP 被称为是无连接的传输层协议。因为没有握手的过程，相当于 TCP 来说，没有建立连接的时延。因为没有连接，所以不需要在端系统中保存连接的状态；
- UDP 提供尽力而为的交付服务，也就是说 UDP 协议不保证数据的可靠交付；
- UDP 没有拥塞控制和流量控制机制，所以 UDP 报文段的发送速率没有限制；
- 因为一个 UDP 套接字只使用目的地址和目的端口来标识，所以 UDP 可以支持一对一、一对多、多对一和多对多的交互通信；
- UDP 首部小，只有 8 个字节

**UDP 报文段结构**

UDP 报文段由首部和应用数据组成。报文段首部包含四个字段，分别是源端口号、目的端口号、长度和检验和，每个字段的长 度为两个字节。长度字段指的是整个报文段的长度，包含了首部和应用数据的大小。校验和是 UDP 提供的一种差错校验机制。 虽然提供了差错校验的机制，但是 UDP 对于差错的恢复无能为力。

![](https://camo.githubusercontent.com/9441fdd8def46c346747b22aa93ed382b0e3f5695ab3e3f30c0468a46f3917f9/68747470733a2f2f636176737a686f75796f752d313235343039333639372e636f732e61702d63686f6e6771696e672e6d7971636c6f75642e636f6d2f6e6f74652d31362e706e67)

### TCP 协议

TCP 协议是面向连接的，提供可靠的数据传输服务的传输层协议。

特点：

- TCP 协议是面向连接的，在通信双方进行通信前，需要通过三次握手建立连接。它需要在端系统中维护双方连接的状态信息；
- TCP 协议通过序号、确认号、定时重传、检验和等机制，来提供可靠的数据传输服务；
- TCP 协议提供的是点对点的服务，即它是在单个发送方和单个接收方之间的连接；
- TCP 协议提供的是全双工的服务，也就是说连接的双方能够向对方发送和接收数据；
- TCP 提供拥塞控制机制，在网络拥塞的时候会控制发送数据的速率，有助于减少数据包的丢失和减轻网络中的拥塞程度；
- TCP 提供了流量控制机制，保证了通信双方的发送和接收速率相同。如果接收方可接收的缓存数量很小时，发送方降低发送速率，避免因为缓存填满而造成的数据包的丢失。

#### 一个 tcp 连接能发几个 http 请求？

如果是 HTTP 1.0 版本协议，一般情况下，不支持长连接，因此在每次请求发送完毕之后，TCP 连接即会断开，因此一个 TCP 发送一个 HTTP 请求，但是有一种情况可以将一条 TCP 连接保持在活跃状态，那就是通过 `Connection` 和 `Keep-Alive` 首部，在请求头带上 `Connection: Keep-Alive`，并且可以通过 `Keep-Alive` 通用首部中指定的，用逗号分隔的选项调节 `keep-alive` 的行为，如果客户端和服务端都支持，那么其实也可以发送多条，不过此方式也有限制，可以关注《HTTP 权威指南》4.5.5 节对于 Keep-Alive 连接的限制和规则。

而如果是 HTTP 1.1 版本协议，支持了长连接，因此只要 TCP 连接不断开，便可以一直发送 HTTP 请求，持续不断，没有上限； 同样，如果是 HTTP 2.0 版本协议，支持多用复用，一个 TCP 连接是可以并发多个 HTTP 请求的，同样也是支持长连接，因此只要不断开 TCP 的连接，HTTP 请求数也是可以没有上限地持续发送。

参考文章：[《计算机网络知识总结》](https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md)
