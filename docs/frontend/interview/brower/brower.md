# 浏览器

## 浏览器架构

- 用户界面
  - 主进程
  - 内核
    - 渲染引擎
    - JS 引擎
      - 执行栈
    - 事件触发线程
      - 消息队列
        - 宏任务
        - 微任务
    - 网络异步线程
    - 定时器线程

## 常见浏览器内核

- Trident，IE

  因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多
  网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。

- Gecko，Firefox

  这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。

- Presto，Opera

  Opera 曾经采用的是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快 3 倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。

- Webkit，Safari

  优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。

- Blink/Chromium，Chrome

  谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是 KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。

## 浏览器缓存机制

浏览器的缓存机制指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 web 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。

web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。

使用**强缓存策略**时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 `Expires` 属性和 `Cache-Control` 属性。

服务器通过在响应头中添加 `Expires` 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。

`Expires` 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 `Cache-Control` 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 `max-age` 来指定资源能够被缓存的时间的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 `Expires`来说，这种方式更加有效一些。常用的还有比如 `private` ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 `no-store` ，用来指定资源不能够被缓存，`no-cache` 不使用本地缓存，使用协商缓存，每次都需要向服务器发起请求。一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，`Cache-Control` 的优先级要高于 `Expires` 。

使用**协商缓存策略**时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 `Etag` 和 `Last-Modified` 属性。

服务器通过在响应头中添加 `Last-Modified` 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 `If-Modified-Since` 的属性，属性值为上一次资源返回时的 `Last-Modified` 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 `Last-Modified` 标注的最后修改时间只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，那么文件已将改变了但是 `Last-Modified` 却没有改变，
这样会造成缓存命中的不准确。

因为 `Last-Modified` 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 `Etag` 属性。服务器在返回资源的时候，在头信息中添加了 `Etag` 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 `If-None-Match` 属性，这个属性的值就是上次返回的资源的 `Etag` 的值。服务接收到请求后会根据这个值来和资源当前的 `Etag` 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 `Last-Modified` 的方式更加精确。

当 `Last-Modified` 和 `Etag` 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 `Last-Modified` 应该保持一致，因为每个服务器上 `Etag` 的值都不一样，因此在考虑负载平衡时，最好不要设置 `Etag` 属性。

强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。

> 相关文章 [彻底理解浏览器缓存机制](https://juejin.cn/post/6844903593275817998#heading-0)，[浏览器的强缓存和协商缓存](https://segmentfault.com/a/1190000021661656)

## 浏览器的同源策略

一个域下的 JavaScript 脚本在未经允许的情况下，不能访问另一个域的内容。同源指的是两个域的协议、域名、端口号必须相同，否则不属于一个域。

同源策略主要限制三个方面：

- 当前域下的脚本不能访问其他域下的 cookie、localStorage 和 indexedDB；
- 当前域下的脚本不能操作访问其他域下的 DOM；
- 当前域下的 AJAX 无法发送跨域请求

同源策略的目的主要是为了保证用户的信息安全，它只是对 JavaScript 脚本的一种限制，并不是对浏览器的限制，对于一般的 image 或者 js 脚本请求都不会有跨域的限制，因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。

### 如何解决跨域问题

1. jsonp
2. document.domain + iframe
3. location.hash + iframe
4. window.name + iframe
5. `postMessage`
6. 跨域资源共享 （CORS）
7. Nginx 代理跨域
8. nodejs 中间件代理跨域
9. WebSocket 协议跨域

学习文章： [《前端常见跨域解决方案（全）》](https://segmentfault.com/a/1190000011145364)

## Cookie

Cookie 是服务器提供的一种用户维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源请求时，将保存的 Cookie 值添加到请求头部，发送给服务端。这可以用来实现用户登录状态等功能。Cookie 一般可以存储 4k 大小的数据，并且只能被同源的网页共享访问。

服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。
