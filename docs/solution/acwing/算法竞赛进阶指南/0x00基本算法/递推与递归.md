# 递推与递归

## 递归实现指数型枚举

#### 解法一：递归 数组枚举

<<< @/docs/solution/acwing/算法竞赛进阶指南/0x00基本算法/src/递推与递归/递归实现指数型枚举1.cpp

#### 解法二：递归 二进制枚举

<<< @/docs/solution/acwing/算法竞赛进阶指南/0x00基本算法/src/递推与递归/递归实现指数型枚举2.cpp

#### 解法三：迭代 二进制枚举

<<< @/docs/solution/acwing/算法竞赛进阶指南/0x00基本算法/src/递推与递归/递归实现指数型枚举3.cpp

## 递归实现组合型枚举

#### 解法一：递归 数组枚举

<<< @/docs/solution/acwing/算法竞赛进阶指南/0x00基本算法/src/递推与递归/递归实现组合型枚举1.cpp

#### 解法二：递归 二进制枚举

<<< @/docs/solution/acwing/算法竞赛进阶指南/0x00基本算法/src/递推与递归/递归实现组合型枚举2.cpp

## 递归实现排列型枚举

#### 解法一：递归 数组枚举

<<< @/docs/solution/acwing/算法竞赛进阶指南/0x00基本算法/src/递推与递归/递归实现排列型枚举1.cpp

#### 解法二：递归 二进制枚举

<<< @/docs/solution/acwing/算法竞赛进阶指南/0x00基本算法/src/递推与递归/递归实现排列型枚举2.cpp

## 费解的开关

#### 解法一: BFS + 状态压缩

从全为 `1` 的状态开始，BFS 搜索6步以内的所有状态

#### 解法二：位运算枚举 + 递推

首先这种 `0` 和 `1` 转换的问题有两点明确：
1. 每个位置只会有一次转换操作，因为如果两次操作则回到原来的状态（无意义），三次操作结果与第一次相同；
2. 一组满足要求的操作序列具有无序性，即操作序列中的任意两个操作，谁先谁后结果都相同。

根据上面两条原则，可以通过递推的方式求解。

当第一行的某一列为 `0` 时，只能通过操作下一行的同一列使其变为 `1`，如果通过改变当前位置则会影响到其他方向上的状态；即 `g[i][j] == '0'` 时，需要改变 `g[i + 1][j]` 使其变为 `1`， 以此类推。

故需要确定第一行的状态，然后递推第二行、第三行和第四行，此时第五行的状态已被确定，故判断第五行是否全为 `1`，即可确定是否可以通过初始状态改变到全为 `1` 的状态。

<<< @/docs/solution/acwing/算法竞赛进阶指南/0x00基本算法/src/递推与递归/费解的开关.cpp

**复杂度分析**

- 时间复杂度 $O(2^5*20*5*n)$，其中第一行的初始状态共 $2^5$ 种，前四行共 $20$ 种可能的操作，每次操作需修改 $5$ 个位置，$n$ 是测试数据量。
- 空间复杂度 $O(1)$，保存初始状态的数组为 $5*5$，忽略不计。


## 奇怪的汉诺塔

## 约数之和

## 分形之城
