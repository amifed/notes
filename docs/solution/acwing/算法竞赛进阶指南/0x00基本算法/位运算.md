# 位运算

[[toc]]

## 移位运算

### [a^b](https://www.acwing.com/problem/content/91/)

快速幂

#### 递归

- 要计算 $a^b$ 时，可以先递归地计算出 $t = a^{\lfloor b/2 \rfloor}$；
- 根据递归计算的结果，如果 $b$ 为偶数，那么 $a^b = t^2$；如果 $n$ 为奇数，那么 $a^b = t^2a$；
- 递归的边界为 $b=0$，$a^0=1$。

#### 迭代

十进制整数进行二进制拆分：$b=2^{t_0}+2^{t_1}+\cdots+2^{t_i}+\cdots+2^{t_n}$，当 $b$ 的二进制的 $i$ 位为 $1$ 时，$t_i = i$，否则 $t_i=0$；

故，$a^b=a^{2^{t_0}+2^{t_1}+\cdots+2^{t_k}}=a^{2^{t_0}}a^{2^{t_1}}\cdots a^{2^{t_k}}$

:::details 参考代码（C++）
<<< @/docs/solution/acwing/算法竞赛进阶指南/0x00基本算法/src/位运算/a^b.cpp
:::

### [64 位整数乘法](https://www.acwing.com/problem/content/92/)

类似于快速幂的思想，整数 $b$ 用二进制表示，即 $b=c_{k-1}2^{k-1}+c_{k-2}2^{k-2}+\cdots +c_02^0$，那么，

$a*b=c_{k-1}*a*2^{k-1}+c_{k-2}*a*2^{k-2}+\cdots +c_0*a*2^0$。

当 $c_i=1$ 时，将乘积累加到答案中即可。

:::details 参考代码（C++）
<<< @/docs/solution/acwing/算法竞赛进阶指南/0x00基本算法/src/位运算/64位整数乘法.cpp
:::

## 二进制状态压缩

### [最短 Hamilton 路径](https://www.acwing.com/problem/content/93/)

#### 状态定义

$f(i,j)\;(0≤i≤2^n,0≤j<n)$ 表示 "点被经过的状态" 对应的二进制数为 $i$ ，且目前处于点 $j$ 时的最短路径。

#### 状态计算

对于 $f(i,j)$，即当前时刻 "被经过的点的状态" 对应的二进制数为 $i$ ，处于点 $j$（此时状态 $i$ 的二进制位的第 $j$ 位应该为 $1$ ，即 $(i\gg j)\;\&\;1 = 1$）。

因为 $j$ 只能被恰好经过一次，所以一定是当前时刻经过，故上一次 "被经过的点的状态" 对应的二进制数的第 $j$ 位应该为 $0$，即 $i\oplus(1\ll j)=1$。另外上一次所处的位置可能是 $i\oplus(1\ll j)=1$ 中任意一个是 $1$ 的数位 $k$，从 $k$ 走到 $j$ 需经过 $weight(k,j)$ 的路程，考虑所有这样的 $k$ 取最小值。 

总结来说，对于当前点 $j$ ，找一个状态，再找一个中间点 $k$，更新 $k$ 点 到 $j$ 点的最短路，该状态要满足 $j$ 点的状态中 $j$ 点被走过，$k$ 点的状态 $j$ 点没被走过、$k$ 点被走过。

$f(i,j)=\min\{f(i\oplus(1 \ll j),k)+weight(k,j)\},\; 0≤k<n,\;((i \gg j) \;\&\; 1) = 1$

#### 初始条件

在起点时，有 $f(1,0)=0$ ，即只经过点 $0$ （ $i$ 只有第 $0$ 位为 $1$ ），目前处于起点 $0$ ，最短路长度为 $0$ 。方便起见，将 $f$ 其他值初始化为无穷大

#### 最终结果

$f(2^n-1,n-1)$，即经过所有点（ $i$ 的所有位都是 $1$ ），处于终点 $n-1$ 的最短路。

:::details 参考代码（C++）
<<< @/docs/solution/acwing/算法竞赛进阶指南/0x00基本算法/src/位运算/最短Hamilton路径.cpp
:::

#### 复杂度分析

- 时间复杂度 $O(n^2*2^n)$
- 空间复杂度 $O(n*2^n)$

### [起床困难综合症](https://www.acwing.com/problem/content/1000/)

​本题意为选择 $[0,m]$ 之间的一个整数 $x_0$，经过给定的 $n$ 次位运算，使结果 $ans$ 最大。

位运算的主要特点之一是**在二进制表示下不进位**。在 $x_0$ 可以任意选择的情况下，参与位运算的各个位（bit）之间是独立无关的。换言之，对于任意的 $k\;(0≤k<30)$，“$ans$ 的第 $k$ 位是几“ 只与 “$x_0$ 的第 $k$ 位是几” 有关，与其他位无关。所以从高位到低位，依次考虑 $x_0$ 的每一位填 $0$ 还是填 $1$。

$x_0$ 的第 $k$ 位应该填 $1$ ，当且仅当同时满足两个条件：

1. 已经填好的更高位构成的数加上 $1\ll k$ 后不超过 $m$；
2. 用每个参数的第 $k$ 位参与位运算。若初值为 $1$ ，则 $n$ 次位运算后结果为 $1$；若初值为 $0$ ，则 $n$ 次位运算后结果为 $0$；

如果不满足上述条件，要么填 $1$ 会超过 $m$ 的范围，要么填 $1$ 不如填 $0$ 更优，因为如果填 $1$ ，而 $n$ 次位运算后变为 $0$，则增加了 $x_0$，却没增大ans，或者低位填 $1$ 导致 $x_0$ 可能大于 $m$ 而得不到最优解。确定 $x_0$ 的每一位后，自然得到 $ans$ 的值。

:::details 参考代码（C++）
<<< @/docs/solution/acwing/算法竞赛进阶指南/0x00基本算法/src/位运算/起床困难综合症.cpp
:::
