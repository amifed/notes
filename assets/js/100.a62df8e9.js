(window.webpackJsonp=window.webpackJsonp||[]).push([[100],{518:function(t,a,e){"use strict";e.r(a);var s=e(18),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"html-常见面试问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html-常见面试问题"}},[t._v("#")]),t._v(" HTML 常见面试问题")]),t._v(" "),e("h2",{attrs:{id:"作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[t._v("#")]),t._v(" <!DOCTYPE html> 作用")]),t._v(" "),e("p",[t._v("DOCTYPE 标签是一种标准通用标记语言的文档类型声明，它的目的是要告诉标准通用标记语言解析器，它应该使用什么样的文档类型定义（DTD）来解析文档。")]),t._v(" "),e("p",[t._v("HTML5：使用方式 <!DOCTYPE html>")]),t._v(" "),e("h2",{attrs:{id:"html、xhtml、html5-的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html、xhtml、html5-的关系"}},[t._v("#")]),t._v(" HTML、XHTML、HTML5 的关系")]),t._v(" "),e("p",[t._v("XHTML 是更严格化的 HTML\nHTML5 是独立的 HTML 规范")]),t._v(" "),e("h2",{attrs:{id:"html5-有什么变化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html5-有什么变化"}},[t._v("#")]),t._v(" HTML5 有什么变化")]),t._v(" "),e("p",[t._v("新的语义化元素\n表单增强\n新的 API（离线、音视频、图像、实时通信、本地存储、设备能力）")]),t._v(" "),e("h2",{attrs:{id:"语义化的意义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语义化的意义"}},[t._v("#")]),t._v(" 语义化的意义")]),t._v(" "),e("p",[t._v("开发者更容易理解\n机器更容易理解结构\nSEO")]),t._v(" "),e("h2",{attrs:{id:"property-和-attribute-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#property-和-attribute-的区别"}},[t._v("#")]),t._v(" property 和 attribute 的区别")]),t._v(" "),e("ul",[e("li",[t._v("attribute 是定义在 html 元素上的属性，可通过 "),e("code",[t._v("getAttribute()")]),t._v(","),e("code",[t._v("setAttribute()")]),t._v(" 读写，但修改后的值不会更新到页面上；")]),t._v(" "),e("li",[t._v("property 在解析时由 attribute 赋值，可以通过 DOM 对象的属性读写，并且会导致页面更新；")]),t._v(" "),e("li",[t._v("attribute 和 property 两者互不相通。")])]),t._v(" "),e("h2",{attrs:{id:"浏览器渲染原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染原理"}},[t._v("#")]),t._v(" 浏览器渲染原理")]),t._v(" "),e("p",[t._v("（1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。")]),t._v(" "),e("p",[t._v("（2）然后对 CSS 进行解析，生成 CSSOM 规则树。")]),t._v(" "),e("p",[t._v("（3）根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。")]),t._v(" "),e("p",[t._v("（4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。")]),t._v(" "),e("p",[t._v("（5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。")]),t._v(" "),e("p",[t._v("这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。")]),t._v(" "),e("h2",{attrs:{id:"重绘、回流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘、回流"}},[t._v("#")]),t._v(" 重绘、回流")]),t._v(" "),e("p",[t._v("重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 "),e("code",[t._v("background-color")]),t._v("，我们将这样的操作称为重绘。")]),t._v(" "),e("p",[t._v("回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。")]),t._v(" "),e("p",[e("strong",[t._v("回流必将引起重绘，重绘不一定会引起回流")])]),t._v(" "),e("p",[t._v("DOM 操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/6844903569087266823",target:"_blank",rel:"noopener noreferrer"}},[t._v("浏览器的回流与重绘 (Reflow & Repaint)"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"html-语义化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html-语义化"}},[t._v("#")]),t._v(" HTML 语义化")]),t._v(" "),e("ol",[e("li",[t._v("用正确的标签做正确的事情。")]),t._v(" "),e("li",[t._v("html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;")]),t._v(" "),e("li",[t._v("即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;")]),t._v(" "),e("li",[t._v("搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;")]),t._v(" "),e("li",[t._v("使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。")])]),t._v(" "),e("h2",{attrs:{id:"浏览器内多个标签页之间的通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器内多个标签页之间的通信"}},[t._v("#")]),t._v(" 浏览器内多个标签页之间的通信")]),t._v(" "),e("ol",[e("li",[t._v("WebSocket，通信标签页连接同一个服务器，发送消息到服务器，服务器推送消息到连接的客户端；")]),t._v(" "),e("li",[t._v("SharedWorker，（仅 Chrome 实现），两个页面共享同一个线程，通过向线程发送数据和接收数据实现双向通信；")]),t._v(" "),e("li",[t._v("可以调用 localStorage、cookies 等本地存储方式，localStorge 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个 storage 事件，我们通过监听 storage 事件，控制它的值来进行页面信息通信；")]),t._v(" "),e("li",[t._v("如果我们能够获得对应标签页的引用，可通过 postMessage 方法实现多个标签页。")])]),t._v(" "),e("h2",{attrs:{id:"canvas-和-svg-有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#canvas-和-svg-有什么区别"}},[t._v("#")]),t._v(" Canvas 和 SVG 有什么区别？")]),t._v(" "),e("p",[t._v("Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时，会出现锯齿或者失真的情况。")]),t._v(" "),e("p",[t._v("SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。")]),t._v(" "),e("h2",{attrs:{id:"前端性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端性能优化"}},[t._v("#")]),t._v(" 前端性能优化")]),t._v(" "),e("p",[t._v("前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。")]),t._v(" "),e("p",[t._v("第一个方面是页面的内容方面")]),t._v(" "),e("p",[t._v("（1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。")]),t._v(" "),e("p",[t._v("（2）通过 DNS 缓存等机制来减少 DNS 的查询次数。")]),t._v(" "),e("p",[t._v("（3）通过设置缓存策略，对常用不变的资源进行缓存。")]),t._v(" "),e("p",[t._v("（4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。")]),t._v(" "),e("p",[t._v("（5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。")]),t._v(" "),e("p",[t._v("第二个方面是服务器方面")]),t._v(" "),e("p",[t._v("（1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。")]),t._v(" "),e("p",[t._v("（2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。")]),t._v(" "),e("p",[t._v("（3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie")]),t._v(" "),e("p",[t._v("第三个方面是 CSS 和 JavaScript 方面")]),t._v(" "),e("p",[t._v("（1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。")]),t._v(" "),e("p",[t._v("（2）避免使用 @import 标签。")]),t._v(" "),e("p",[t._v("（3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。")]),t._v(" "),e("p",[t._v("（4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。")]),t._v(" "),e("p",[t._v("参考文章："),e("a",{attrs:{href:"https://juejin.cn/post/6844903657318645767#heading-10",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端性能优化之雅虎 35 条军规"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dom"}},[t._v("#")]),t._v(" DOM")]),t._v(" "),e("h3",{attrs:{id:"scrollheight-scrollwidth"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#scrollheight-scrollwidth"}},[t._v("#")]),t._v(" scrollHeight/scrollWidth")]),t._v(" "),e("p",[e("code",[t._v("scrollHeight")]),t._v(" 属性返回元素的整个高度（以像素为单位），包括填充，但不包括边框，滚动条或边距。"),e("code",[t._v("scrollWidth")]),t._v(" 和 "),e("code",[t._v("scrollHeight")]),t._v(" 属性返回元素的整个高度和宽度，包括不可见的高度和宽度（由于溢出）。")]),t._v(" "),e("h3",{attrs:{id:"scrollleft-scrolltop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#scrollleft-scrolltop"}},[t._v("#")]),t._v(" scrollLeft/scrollTop")]),t._v(" "),e("p",[e("code",[t._v("scrollTop")]),t._v(" 属性设置或返回垂直滚动元素内容的像素数。")]),t._v(" "),e("p",[e("code",[t._v("scrollLeft")]),t._v(" 属性设置或返回元素内容水平滚动的像素数。")]),t._v(" "),e("h3",{attrs:{id:"clientheight-clientwidth"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#clientheight-clientwidth"}},[t._v("#")]),t._v(" clientHeight/clientWidth")]),t._v(" "),e("p",[e("code",[t._v("clientHeight")]),t._v(" 属性返回元素的可见高度（以像素为单位），包括填充，但不包括边框，滚动条或边距。之所以指定“可见”一词，是因为如果元素的内容比元素的实际高度高，则此属性将仅返回可见的高度。（滚动条会“窃取”这个值，导致得到一个低于实际值的值）")]),t._v(" "),e("h3",{attrs:{id:"offsetheight-offsetwidth"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#offsetheight-offsetwidth"}},[t._v("#")]),t._v(" offsetHeight/offsetWidth")]),t._v(" "),e("p",[e("code",[t._v("offsetHeight")]),t._v(" 属性返回元素的可见高度（以像素为单位），包括填充，边框和滚动条，但不包括边距。之所以指定“可见”一词，是因为如果元素的内容比元素的实际高度高，则此属性将仅返回可见的高度")]),t._v(" "),e("h3",{attrs:{id:"offsetparent-和-offsetleft-offsettop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#offsetparent-和-offsetleft-offsettop"}},[t._v("#")]),t._v(" offsetParent 和 offsetLeft/offsetTop")]),t._v(" "),e("p",[e("code",[t._v("offsetParent")]),t._v(" 属性返回位置不是静态的最接近的祖先。")]),t._v(" "),e("p",[e("code",[t._v("offsetLeft")]),t._v(" 属性返回相对于 "),e("code",[t._v("offsetParent")]),t._v(" 元素左侧的左侧位置（以像素为单位）。返回的值包括：")]),t._v(" "),e("ul",[e("li",[t._v("元素的左侧位置和边距")]),t._v(" "),e("li",[e("code",[t._v("offsetParent")]),t._v(" 元素的左侧填充，滚动条和边框")])]),t._v(" "),e("p",[e("code",[t._v("offsetTop")]),t._v(" 属性返回相对于 "),e("code",[t._v("offsetParent")]),t._v(" 元素顶部的顶部位置（以像素为单位）。返回的值包括：")]),t._v(" "),e("ul",[e("li",[t._v("元素的最高位置和边距")]),t._v(" "),e("li",[e("code",[t._v("offsetParent")]),t._v(" 元素的顶部填充，滚动条和边框")])]),t._v(" "),e("blockquote",[e("p",[t._v("offsetParent 与 offsetLeft 和 offsetTop 属性一起使用。可获得元素的"),e("strong",[t._v("位置")])])]),t._v(" "),e("h3",{attrs:{id:"element-getboundingclientrect"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#element-getboundingclientrect"}},[t._v("#")]),t._v(" Element.getBoundingClientRect()")]),t._v(" "),e("p",[e("code",[t._v("Element.getBoundingClientRect()")]),t._v(" 方法返回元素的大小及其相对于视口的位置。返回值是一个 DOMRect 对象。")]),t._v(" "),e("h3",{attrs:{id:"使用举例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用举例"}},[t._v("#")]),t._v(" 使用举例")]),t._v(" "),e("h4",{attrs:{id:"无限滚动-上拉加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#无限滚动-上拉加载"}},[t._v("#")]),t._v(" 无限滚动（上拉加载）")]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取滚动高度、元素可见高度、元素高度（包含溢出内容）")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" pageSize "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  pageNum "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" scrollTop"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" clientHeight"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" scrollHeight "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("documentElement\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("scrollTop "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" clientHeight "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" scrollHeight"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 加载数据")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("loadData")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pageSize"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("pageNum"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br")])])])}),[],!1,null,null,null);a.default=r.exports}}]);